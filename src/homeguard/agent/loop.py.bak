"""Agent loop with human-in-the-loop safety."""

import json
import re
import warnings
from datetime import datetime

import httpx
import questionary
from rich.console import Console
from rich.panel import Panel

from .config import LLMConfig, load_config, DEFAULT_BACKEND_URL
from .llm import SYSTEM_PROMPT, chat_with_tools, extract_tool_calls, get_response_text
from .tools import (
    execute_tool, get_tool_risk, format_tool_result, RiskLevel,
    identify_device_type, extract_vendor_from_scan_data, detect_device_model, get_mac_vendor
)
from .report import ScanReport, DeviceReport, generate_scan_id, save_report, format_cli_report

warnings.filterwarnings("ignore", message="Pydantic serializer warnings")

console = Console()
MAX_ITERATIONS = 25

# Vendor name mappings for threat intel search
VENDOR_MAPPINGS = {
    "tp-link": "tp-link", "beijing xiaomi": "xiaomi", "xiaomi": "xiaomi",
    "gree electric": "gree", "asustek": "asus", "asus": "asus",
    "apple": "apple", "bsh hausgeraete": "bosch", "huawei": "huawei",
    "samsung": "samsung", "netgear": "netgear", "d-link": "dlink",
    "ubiquiti": "ubiquiti", "hikvision": "hikvision", "dahua": "dahua",
    "synology": "synology", "qnap": "qnap", "cisco": "cisco",
    "linksys": "linksys", "zyxel": "zyxel", "mikrotik": "mikrotik",
    "ring": "ring", "nest": "nest", "philips": "philips",
    "sonos": "sonos", "roku": "roku", "amazon": "amazon",
}


def _normalize_vendor_name(vendor: str) -> str:
    """Normalize vendor name for better threat intel search."""
    if not vendor or vendor == "Unknown":
        return vendor
    vendor_lower = vendor.lower()
    for pattern, normalized in VENDOR_MAPPINGS.items():
        if pattern in vendor_lower:
            return normalized
    return vendor.split()[0].lower() if vendor else vendor


# === UI Helpers ===

def _show_thinking(text: str):
    if text:
        console.print(Panel(text, title="ðŸ¤– AI", border_style="cyan"))


def _show_tool_call(name: str, args: dict):
    args_str = ", ".join(f"{k}={v}" for k, v in args.items()) if args else ""
    console.print(f"[dim]â†’ Calling:[/dim] [cyan]{name}[/cyan]({args_str})")


def _request_approval(name: str, args: dict, risk: RiskLevel) -> str:
    colors = {RiskLevel.LOW: "green", RiskLevel.MEDIUM: "yellow", RiskLevel.HIGH: "orange1", RiskLevel.CRITICAL: "red"}
    color = colors[risk]
    console.print(Panel(
        f"[bold]Action:[/bold] {name}\n[bold]Risk Level:[/bold] [{color}]{risk.value.upper()}[/{color}]\n\n[bold]Details:[/bold]\n{json.dumps(args, indent=2)}",
        title="ðŸ¤– AI wants to perform an action", border_style=color,
    ))
    choice = questionary.select("Allow this action?", choices=[
        questionary.Choice("âœ… Yes, proceed", value="yes"),
        questionary.Choice("âŒ No, skip this", value="no"),
        questionary.Choice("ðŸ›‘ Stop AI scan", value="stop"),
    ]).ask()
    return choice or "no"


def _show_fix_suggestion(issue: str, command: str, explanation: str) -> str:
    console.print(Panel(
        f"[bold]Issue:[/bold] {issue}\n\n[bold]Suggested Command:[/bold]\n[cyan]{command}[/cyan]\n\n[bold]Explanation:[/bold] {explanation}",
        title="ðŸ”§ Suggested Fix", border_style="yellow",
    ))
    choice = questionary.select("What would you like to do?", choices=[
        questionary.Choice("ðŸ“‹ Copy command", value="copy"),
        questionary.Choice("ðŸ“ Note it for later", value="note"),
        questionary.Choice("âŒ Skip", value="skip"),
    ]).ask()
    if choice == "copy":
        try:
            import pyperclip
            pyperclip.copy(command)
            console.print("[green]âœ“ Copied to clipboard[/green]")
        except ImportError:
            console.print(f"[yellow]Command:[/yellow] {command}")
    return choice or "skip"


# === Scan Data Handlers ===

def _handle_scan_network(result, scan_data: dict):
    """Process scan_network results."""
    data = result.data
    scan_data["network"] = data.get("network", scan_data["network"])
    for dev in data.get("devices", []):
        ip = dev.get("ip")
        mac = dev.get("mac", "Unknown")
        vendor = get_mac_vendor(mac)
        scan_data["device_map"][ip] = {
            "ip": ip, "mac": mac, "os_guess": dev.get("os_guess", "Unknown"),
            "device_type": "Unknown", "vendor": vendor, "open_ports": [], "risks": [],
        }
        if vendor != "Unknown":
            console.print(f"[dim]   {ip}: {vendor}[/dim]")


def _handle_scan_ports(ip: str, result, scan_data: dict, backend_url: str):
    """Process scan_ports results and run auto checks."""
    if ip not in scan_data["device_map"]:
        return
    
    ports = result.data.get("open_ports", [])
    scan_data["device_map"][ip]["open_ports"] = ports
    port_numbers = [p.get("port") for p in ports if p.get("port")]
    
    # Identify device
    device_info = identify_device_type(
        ip, scan_data["device_map"][ip].get("mac", "Unknown"),
        port_numbers, scan_data["device_map"][ip].get("os_guess", "Unknown"),
    )
    device_type = device_info.get("device_type", "Unknown")
    scan_data["device_map"][ip]["device_type"] = device_type
    scan_data["device_map"][ip]["vendor"] = device_info.get("vendor", "Unknown")
    result.data["device_type"] = device_type
    
    # Run deep scan
    deep_scan_result = _run_deep_scan(ip, device_type, port_numbers, scan_data)
    if deep_scan_result:
        scan_data["device_map"][ip]["deep_scan"] = deep_scan_result.data
        result.data["deep_scan"] = deep_scan_result.data
    
    # Run security checks for web devices
    if any(p.get("port") in [80, 443, 8080, 8443] for p in ports):
        _run_security_checks(ip, scan_data)
    
    # Query threat intel
    _run_threat_intel(ip, device_type, scan_data, backend_url)


def _run_deep_scan(ip: str, device_type: str, port_numbers: list, scan_data: dict):
    """Run appropriate deep scan based on device type."""
    deep_scan_result = None
    
    if "Router" in device_type:
        console.print(f"[dim]â†’ Auto deep scan:[/dim] [cyan]deep_scan_router[/cyan]({ip})")
        deep_scan_result = execute_tool("deep_scan_router", {"ip": ip})
        if deep_scan_result and deep_scan_result.success:
            http_info = deep_scan_result.data.get("http_info", {})
            vendor = extract_vendor_from_scan_data(deep_scan_result.data, http_info)
            if vendor != "Unknown":
                scan_data["device_map"][ip]["vendor"] = vendor
                console.print(f"[dim]   Vendor detected:[/dim] [green]{vendor}[/green]")
        # Router-specific checks
        for check in ["check_upnp_exposure", "check_dns_hijacking"]:
            console.print(f"[dim]â†’ Auto check:[/dim] [cyan]{check}[/cyan]({ip})")
            check_result = execute_tool(check, {"ip": ip})
            if check_result and check_result.success:
                key = "upnp_check" if "upnp" in check else "dns_check"
                scan_data["device_map"][ip][key] = check_result.data
                
    elif device_type in ["IoT Device", "Smart TV / Streaming Device", "IP Camera"]:
        console.print(f"[dim]â†’ Auto deep scan:[/dim] [cyan]deep_scan_iot[/cyan]({ip})")
        deep_scan_result = execute_tool("deep_scan_iot", {"ip": ip})
        
    elif device_type in ["NAS / Storage", "Server"]:
        console.print(f"[dim]â†’ Auto deep scan:[/dim] [cyan]deep_scan_storage[/cyan]({ip})")
        deep_scan_result = execute_tool("deep_scan_storage", {"ip": ip})
        
    elif device_type == "Unknown Device":
        console.print(f"[dim]â†’ Auto probe:[/dim] [cyan]probe_unknown_device[/cyan]({ip})")
        deep_scan_result = execute_tool("probe_unknown_device", {"ip": ip, "known_ports": port_numbers})
        if deep_scan_result and deep_scan_result.success:
            probed_type = deep_scan_result.data.get("possible_type", "Unknown")
            if probed_type != "Unknown":
                scan_data["device_map"][ip]["device_type"] = probed_type
    
    # Extract vendor from deep scan
    if deep_scan_result and deep_scan_result.success:
        http_info = deep_scan_result.data.get("http_info", {})
        banners = deep_scan_result.data.get("banners", {})
        vendor = extract_vendor_from_scan_data(deep_scan_result.data, http_info, banners)
        if vendor != "Unknown":
            scan_data["device_map"][ip]["vendor"] = vendor
            console.print(f"[dim]   Vendor detected:[/dim] [green]{vendor}[/green]")
    
    return deep_scan_result


def _run_security_checks(ip: str, scan_data: dict):
    """Run security checks on devices with web interfaces."""
    # Model detection
    console.print(f"[dim]â†’ Auto detect:[/dim] [cyan]detect_device_model[/cyan]({ip})")
    model_info = detect_device_model(ip)
    if model_info.get("model"):
        scan_data["device_map"][ip]["model"] = model_info["model"]
        console.print(f"[dim]   Model detected:[/dim] [green]{model_info['model']}[/green]")
    if model_info.get("firmware"):
        scan_data["device_map"][ip]["firmware_version"] = model_info["firmware"]
        console.print(f"[dim]   Firmware:[/dim] [yellow]{model_info['firmware']}[/yellow]")
    
    # Encryption and firmware checks
    for check, key in [("check_encryption", "encryption_check"), ("check_firmware_age", "firmware_check")]:
        console.print(f"[dim]â†’ Auto check:[/dim] [cyan]{check}[/cyan]({ip})")
        result = execute_tool(check, {"ip": ip})
        if result and result.success:
            scan_data["device_map"][ip][key] = result.data


def _run_threat_intel(ip: str, device_type: str, scan_data: dict, backend_url: str):
    """Query threat intelligence for device."""
    vendor = scan_data["device_map"][ip].get("vendor", "Unknown")
    model = scan_data["device_map"][ip].get("model")
    
    if vendor and vendor != "Unknown":
        search_vendor = _normalize_vendor_name(vendor)
        search_term = f"{search_vendor} {model}" if model else search_vendor
        console.print(f"[dim]â†’ Auto check:[/dim] [cyan]check_threat_intel[/cyan]({search_term})")
        ti_result = execute_tool("check_threat_intel", {"ip": ip, "check_type": "vendor", "vendor": search_term}, backend_url=backend_url)
        if ti_result and ti_result.success:
            scan_data["device_map"][ip]["threat_intel"] = ti_result.data
    
    # IoT-specific exploits
    if device_type in ["IoT Device", "Smart TV / Streaming Device", "IP Camera"]:
        search_vendor = _normalize_vendor_name(vendor) if vendor != "Unknown" else "generic"
        iot_search = f"{search_vendor} {model}" if model else search_vendor
        console.print(f"[dim]â†’ Auto check:[/dim] [cyan]check_threat_intel[/cyan](iot={iot_search})")
        ti_result = execute_tool("check_threat_intel", {"ip": ip, "check_type": "iot", "vendor": iot_search}, backend_url=backend_url)
        if ti_result and ti_result.success:
            existing = scan_data["device_map"][ip].get("threat_intel", {})
            existing["iot_exploits"] = ti_result.data.get("exploits", [])
            scan_data["device_map"][ip]["threat_intel"] = existing


# === Report Generation ===

def _generate_findings(scan_data: dict) -> tuple[list, list, dict, str]:
    """Generate findings and recommendations from scan data."""
    findings, recommendations = [], []
    risk_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}
    
    for device in scan_data["devices"]:
        ip, device_type = device.get("ip", ""), device.get("device_type", "Unknown")
        device_risks = []
        
        for port in device.get("open_ports", []):
            port_num = port.get("port")
            risk = port.get("risk", "low")
            risk_counts[risk] = risk_counts.get(risk, 0) + 1
            
            if risk == "critical":
                if port_num == 445:
                    findings.append(f"ðŸ”´ CRITICAL: {device_type} ({ip}) has SMB exposed - ransomware risk")
                elif port_num == 23:
                    findings.append(f"ðŸ”´ CRITICAL: {device_type} ({ip}) has Telnet open")
                device_risks.append("critical")
            elif risk == "high":
                if port_num in [3306, 5432, 27017]:
                    findings.append(f"ðŸŸ  HIGH: {device_type} ({ip}) has database exposed")
                device_risks.append("high")
            elif risk == "medium":
                if port_num == 80 and "Router" in device_type:
                    findings.append(f"ðŸŸ¡ MEDIUM: Router ({ip}) has HTTP admin exposed")
                    recommendations.append("Access router admin via HTTPS instead of HTTP")
                elif port_num == 22:
                    findings.append(f"ðŸŸ¡ MEDIUM: {device_type} ({ip}) has SSH exposed")
                device_risks.append("medium")
        
        device["risks"] = device_risks
    
    # Determine overall risk
    if risk_counts["critical"] > 0:
        overall_risk = "critical"
    elif risk_counts["high"] > 0:
        overall_risk = "high"
    elif risk_counts["medium"] > 0:
        overall_risk = "medium"
    else:
        overall_risk = "low"
    
    if not findings:
        findings.append("âœ… No critical security issues found")
    
    return findings, recommendations, risk_counts, overall_risk


def _generate_llm_recommendations(scan_data: dict, backend_url: str) -> list[str]:
    """Use LLM to generate recommendations based on all scan data."""
    summary = "Network scan results:\n\n"
    for device in scan_data.get("devices", []):
        summary += f"Device: {device.get('ip')} - {device.get('device_type', 'Unknown')}\n"
        summary += f"  Vendor: {device.get('vendor', 'Unknown')}\n"
        if device.get('model'):
            summary += f"  Model: {device.get('model')}\n"
        if device.get('open_ports'):
            ports = [f"{p.get('port')}/{p.get('service', '?')}" for p in device['open_ports']]
            summary += f"  Ports: {', '.join(ports)}\n"
        if device.get('threat_intel', {}).get('advisories'):
            advs = device['threat_intel']['advisories']
            critical = sum(1 for a in advs if a.get('severity') == 'CRITICAL')
            summary += f"  CVEs: {len(advs)} ({critical} critical)\n"
        summary += "\n"
    
    prompt = f"""Based on this network security scan, provide 5-8 specific, actionable recommendations.
Focus on critical issues first. Be specific about which devices need attention.

{summary}

Respond with ONLY a JSON array of strings. Example:
["Update TP-Link router firmware", "Patch Xiaomi device - 3 critical CVEs"]"""

    try:
        response = httpx.post(f"{backend_url}/api/chat", json={"messages": [{"role": "user", "content": prompt}]}, timeout=30.0)
        response.raise_for_status()
        content = response.json().get("message", {}).get("content", "")
        match = re.search(r'\[.*\]', content, re.DOTALL)
        if match:
            return json.loads(match.group())
    except Exception as e:
        console.print(f"[dim]Could not generate AI recommendations: {e}[/dim]")
    return []


def _build_device_report(device_data: dict) -> DeviceReport:
    """Build a DeviceReport from device data."""
    return DeviceReport(
        ip=device_data.get("ip", ""),
        mac=device_data.get("mac", "Unknown"),
        device_type=device_data.get("device_type", "Unknown"),
        vendor=device_data.get("vendor", "Unknown"),
        os_guess=device_data.get("os_guess", "Unknown"),
        model=device_data.get("model", ""),
        firmware_version=device_data.get("firmware_version", ""),
        open_ports=device_data.get("open_ports", []),
        risks=device_data.get("risks", []),
        recommendations=device_data.get("recommendations", []),
        deep_scan=device_data.get("deep_scan", {}),
        encryption_check=device_data.get("encryption_check", {}),
        firmware_check=device_data.get("firmware_check", {}),
        upnp_check=device_data.get("upnp_check", {}),
        dns_check=device_data.get("dns_check", {}),
        threat_intel=device_data.get("threat_intel", {}),
        llm_identification=device_data.get("llm_identification", {}),
    )


def _save_final_report(scan_data: dict, backend_url: str):
    """Generate and save the final report."""
    scan_data["devices"] = list(scan_data["device_map"].values())
    if not scan_data["devices"]:
        return
    
    findings, recommendations, risk_counts, overall_risk = _generate_findings(scan_data)
    
    report = ScanReport(
        scan_id=generate_scan_id(),
        scan_time=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        network=scan_data.get("network", "Unknown"),
        scan_mode=scan_data.get("scan_mode", "quick"),
        total_devices=len(scan_data["devices"]),
        overall_findings=findings,
        overall_recommendations=recommendations,
        overall_risk=overall_risk,
        risk_summary=risk_counts,
    )
    
    for device_data in scan_data["devices"]:
        report.devices.append(_build_device_report(device_data))
    
    # LLM recommendations
    console.print("[dim]â†’ Generating AI recommendations...[/dim]")
    llm_recs = _generate_llm_recommendations(scan_data, backend_url)
    if llm_recs:
        report.overall_recommendations = llm_recs
    
    save_report(report)
    console.print()
    console.print(format_cli_report(report))


# === Main Agent Loop ===

def run_agent(config: LLMConfig) -> None:
    """Run the AI agent loop."""
    console.print(Panel("ðŸ¤– Starting AI Security Scan...", style="cyan"))
    console.print(f"[dim]Scan mode: {config.scan_mode}[/dim]\n")

    backend_url = config.base_url or DEFAULT_BACKEND_URL
    scan_data = {"network": "Unknown", "scan_mode": config.scan_mode, "devices": [], "device_map": {}}
    
    system_prompt = SYSTEM_PROMPT + f"\n\nScan mode is set to '{config.scan_mode}'."
    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": f"Scan my network with {config.scan_mode} mode. Discover devices, then analyze each one."},
    ]

    for _ in range(MAX_ITERATIONS):
        try:
            response = chat_with_tools(messages, config)
        except Exception as e:
            console.print(f"[red]Error: {e}[/red]")
            break

        text = get_response_text(response)
        if text:
            _show_thinking(text)

        tool_calls = extract_tool_calls(response)
        if not tool_calls:
            break

        tool_results = []
        stop_requested = False

        for tc in tool_calls:
            name, args, tool_id = tc["name"], tc["arguments"], tc["id"]

            # Special handlers
            if name == "generate_report":
                report = build_report_from_findings(args.get("findings", []), args.get("recommendations", []), args.get("risk_level", "low"), scan_data)
                filepath = save_report(report)
                console.print(format_cli_report(report))
                tool_results.append({"tool_call_id": tool_id, "content": f"Report saved to {filepath}"})
                continue

            if name == "suggest_fix":
                choice = _show_fix_suggestion(args.get("issue", ""), args.get("command", ""), args.get("explanation", ""))
                tool_results.append({"tool_call_id": tool_id, "content": f"User chose: {choice}"})
                continue

            risk, auto_approve = get_tool_risk(name)

            if auto_approve:
                _show_tool_call(name, args)
                result = execute_tool(name, args, backend_url=backend_url)
                
                if name == "scan_network" and result.success:
                    _handle_scan_network(result, scan_data)
                elif name == "scan_ports" and result.success:
                    _handle_scan_ports(args.get("ip"), result, scan_data, backend_url)
                elif name == "identify_device" and result.success:
                    ip = args.get("ip")
                    if ip in scan_data["device_map"]:
                        scan_data["device_map"][ip].update({
                            "device_type": result.data.get("device_type", "Unknown"),
                            "vendor": result.data.get("vendor", "Unknown"),
                        })
                
                tool_results.append({"tool_call_id": tool_id, "content": format_tool_result(result)})
            else:
                approval = _request_approval(name, args, risk)
                if approval == "yes":
                    result = execute_tool(name, args, backend_url=backend_url)
                    tool_results.append({"tool_call_id": tool_id, "content": format_tool_result(result)})
                elif approval == "stop":
                    stop_requested = True
                    tool_results.append({"tool_call_id": tool_id, "content": "User stopped the scan."})
                    break
                else:
                    tool_results.append({"tool_call_id": tool_id, "content": "User denied this action."})

        scan_data["devices"] = list(scan_data["device_map"].values())

        if stop_requested:
            console.print("\n[yellow]AI scan stopped by user.[/yellow]")
            break

        # Update message history
        assistant_msg = {"role": "assistant", "content": response.choices[0].message.content}
        if response.choices[0].message.tool_calls:
            assistant_msg["tool_calls"] = [
                {"id": tc.id, "type": "function", "function": {"name": tc.function.name, "arguments": tc.function.arguments}}
                for tc in response.choices[0].message.tool_calls
            ]
        messages.append(assistant_msg)
        for tr in tool_results:
            messages.append({"role": "tool", "tool_call_id": tr["tool_call_id"], "content": tr["content"]})

    # Save final report
    _save_final_report(scan_data, backend_url)
    console.print("\n[cyan]AI scan complete.[/cyan]")


def build_report_from_findings(findings: list, recommendations: list, risk_level: str, scan_data: dict) -> ScanReport:
    """Build a ScanReport from AI findings."""
    report = ScanReport(
        scan_id=generate_scan_id(),
        scan_time=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        network=scan_data.get("network", "Unknown"),
        scan_mode=scan_data.get("scan_mode", "quick"),
        total_devices=len(scan_data.get("devices", [])),
        overall_findings=findings,
        overall_recommendations=recommendations,
        overall_risk=risk_level,
    )
    for device_data in scan_data.get("devices", []):
        report.devices.append(_build_device_report(device_data))
    return report


def run_agent_interactive() -> None:
    """Run agent with config check/setup."""
    config = load_config()
    provider_info = "HomeGuard backend" if config.is_backend_proxy else f"{config.provider} / {config.model}"
    console.print(f"[dim]Using {provider_info}[/dim]\n")
    run_agent(config)
